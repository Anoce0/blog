<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.2.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha256-XOqroi11tY4EFQMR9ZYwZWKj5ZXiftSx36RRuC3anlA=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"anoce0.github.io","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.20.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"Searching...","empty":"We didn't find any results for the search: ${query}","hits_time":"${hits} results found in ${time} ms","hits":"${hits} results found"}}</script><script src="/js/config.js"></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="Ocean&#39;s Blog">
<meta property="og:url" content="https://anoce0.github.io/index.html">
<meta property="og:site_name" content="Ocean&#39;s Blog">
<meta property="og:locale" content="en_US">
<meta property="article:author" content="Ocean Wang">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="https://anoce0.github.io/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"en","comments":"","permalink":"","path":"index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Ocean's Blog</title>
  








  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="Toggle navigation bar" role="button">
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Ocean's Blog</h1>
      <i class="logo-line"></i>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="Search" role="button">
    </div>
  </div>
</div>







</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          Table of Contents
        </li>
        <li class="sidebar-nav-overview">
          Overview
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Ocean Wang</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">8</span>
          <span class="site-state-item-name">posts</span>
        </a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">9</span>
        <span class="site-state-item-name">tags</span></a>
      </div>
  </nav>
</div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/06/08/ngc-vs-tsc/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/06/08/ngc-vs-tsc/" class="post-title-link" itemprop="url">angular 中的 ngc 命令</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-06-08 19:21:15" itemprop="dateCreated datePublished" datetime="2021-06-08T19:21:15+08:00">2021-06-08</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="关于-ngc"><a href="#关于-ngc" class="headerlink" title="关于 ngc"></a>关于 ngc</h2><p>ngc ,全称是 <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/51893626">Angular Template Compiler</a> ,来源于包 <code>@angular/compiler-cli</code>.</p>
<h2 id="ngc-与-tsc"><a href="#ngc-与-tsc" class="headerlink" title="ngc 与 tsc"></a>ngc 与 tsc</h2><p>它在 angular 官网缺乏相关的文档, 有人在 angular repo 中提了个 <a target="_blank" rel="noopener" href="https://github.com/angular/angular/issues/29623">issue</a> 来讨论这个问题.<br>同时有个 <a target="_blank" rel="noopener" href="https://github.com/iRealNirmal/angular/commit/748db836c696ab5ac66e1cefb85192740ec8db32?short_path=0a65f1d#diff-0a65f1d37c6a41d9b8c6e91e484e9e58bb815f22e9b3425432c086c1b904eefa">PR</a> 正在在给 angular 添加 <code>ngc</code> 的 document<br>摘录如下:  </p>
<blockquote>
<p>While most of the time you interact with the Angular Compiler indirectly using Angular CLI, when debugging certain issues, you might find it useful to invoke the Angular Compiler directly. You can use the ngc command provided by the @angular/compiler-cli npm package to call the compiler from the command line.<br>The ngc command is just a wrapper around TypeScript’s tsc compiler command and is primarily configured via the tsconfig.json configuration options documented in the previous sections.<br>In addition to the configuration file, you can also use tsc command line options to configure ngc.  </p>
</blockquote>
<p>这里说 <code>ngc</code> 是 <code>tsc</code> 的一个 Wrapper, 我的实际测试发现这两个命令编译出来的包大小并不想等等, ngc 会更大一点.</p>
<p>tsc and ngc have different purposes and it’s not about selecting one over the other.</p>
<p>tsc is a TypeScript compiler, and you need it to generate JavaScript if your app is written in TypeScript.</p>
<p>ngc is an Angular-specific compiler. It doesn’t turn the TypeScript code into JavaScript. It does a “finishing touch” to make your app bundles ready for rendering by the browser. In particular, it turns your components templates into inline JavaScript. If you do a prod build with Ahead of Time (AoT) compilation, the ngc does its part before the bundles are built. In dev mode we use Just-in-Time compilation: the templates are not precompiled, the ngc compiler is included into the bundles, and it compiles the templates after the browser loaded your bundles.</p>
<p>see <a target="_blank" rel="noopener" href="https://stackoverflow.com/a/50111982">Angular: ngc or tsc?</a></p>
<h2 id="ngc-与-ng-build"><a href="#ngc-与-ng-build" class="headerlink" title="ngc 与 ng build"></a>ngc 与 ng build</h2><p>stackoverflow 有人提了这个<a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/44642696/whats-the-relationship-and-difference-between-ng-build-and-ngc">问题</a><br>简单解释:<br>Angular 提供了两种编译工具,JIT(Just in Time) and AOT (Ahead of Time compile) .<br><code>ng</code> == JIT<br><code>ngc</code> == AOT</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/05/24/ways-of-creating-class-in-js/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/24/ways-of-creating-class-in-js/" class="post-title-link" itemprop="url">Javascript 创建对象的几种方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-24 23:08:07" itemprop="dateCreated datePublished" datetime="2021-05-24T23:08:07+08:00">2021-05-24</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>在经典的面向对象语言中，对象是指数据和在这些数据上进行的操作的集合。与 C++ 和 Java 不同，JavaScript 是一种基于原型的编程语言，并没有 class 语句，而是把函数用作类, 定义对象的方式与其他语言有很多不同.</p>
<h3 id="1-通过方法创造并返回对象"><a href="#1-通过方法创造并返回对象" class="headerlink" title="1. 通过方法创造并返回对象"></a>1. 通过方法创造并返回对象</h3><p>例如,我们希望得到一个以下的数据和操作的集合:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">first</span>: first,</span><br><span class="line">        <span class="attr">last</span>: last,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullName</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + person.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullNameReversed</span>(<span class="params">person</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> person.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + person.<span class="property">first</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> s = <span class="title function_">makePerson</span>(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br><span class="line"><span class="title function_">personFullName</span>(s); <span class="comment">// &quot;Simon Willison&quot;</span></span><br><span class="line"><span class="title function_">personFullNameReversed</span>(s); <span class="comment">// &quot;Willison, Simon&quot;</span></span><br></pre></td></tr></table></figure>

<p>上述方法定义到一个方法中可以变成一下这个样子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">makePerson</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="attr">first</span>: first,</span><br><span class="line">        <span class="attr">last</span>: last,</span><br><span class="line">        <span class="attr">fullName</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="attr">fullNameReversed</span>: <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = <span class="title function_">makePerson</span>(<span class="string">&#x27;Ocean&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>);</span><br><span class="line">person.<span class="title function_">fullName</span>(); <span class="comment">// Ocean Wang</span></span><br><span class="line">person.<span class="title function_">fullNameReversed</span>(); <span class="comment">// Wang Ocean</span></span><br></pre></td></tr></table></figure>

<h3 id="2-使用-this-与-new-关键字"><a href="#2-使用-this-与-new-关键字" class="headerlink" title="2. 使用 this 与 new 关键字"></a>2. 使用 this 与 new 关键字</h3><p>上述写法使用了 <code>this</code> 关键字, JS 中的 <code>this</code> 关键字与 Java 中的 <code>this</code> 永远指向当前实例不同, JS 中的 <code>this</code> 是由当前的调用环境决定的.<br>当使用在函数中时，this 指代当前的对象，也就是调用了函数的对象。如果在一个对象上使用点或者方括号来访问属性或方法，这个对象就成了 this。如果并没有使用“点”运算符调用某个对象，那么 this 将指向全局对象（global object）。这是一个经常出错的地方。例如：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = <span class="title function_">makePerson</span>(<span class="string">&#x27;Ocean&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>);</span><br><span class="line"><span class="keyword">let</span> fullName = person.<span class="property">fullName</span>;</span><br><span class="line"><span class="title function_">fullName</span>(); <span class="comment">// undefined undefined</span></span><br></pre></td></tr></table></figure>

<p>通过利用 <code>this</code> 指代当前对象的特点, 我们可以将上述类定义成以下这个样子</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们注意到,这个函数是没有返回值的, 如果我们试图调用这个函数, 实际返回的是 <code>undefined</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="title class_">Person</span>(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<p>那如果我们将 <code>this</code> 返回会怎么样呢? 就像我们刚刚说的,this 指代当前的对象，在下面的调用中, this 实际指向的是全局对象（global object）, 实际上下面代码做的事情是 将 last,first, fullName 绑定到了全局对象中,并且返回了全局对象.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>(); <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">fullName</span>; <span class="comment">// function</span></span><br></pre></td></tr></table></figure>

<p>好在为了解决这种问题, javascript 提供了 <code>new</code> 关键字,帮我们正确的从函数初始化一个对象,正确绑定并返回 <code>this</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Ocean&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>); <span class="comment">// person object</span></span><br></pre></td></tr></table></figure>

<p><code>new</code> 关键字在运行是会生成一个新的对象, 并且将 <code>this</code> 绑定到这个对象, 然后返回它, 可以用一下的代码来模拟:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">trivialNew</span>(<span class="params">constructor, ...args</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> o = &#123;&#125;; <span class="comment">// 创建一个对象</span></span><br><span class="line">    constructor.<span class="title function_">apply</span>(o, args);</span><br><span class="line">    <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> persion = <span class="title function_">trivialNew</span>(<span class="title class_">Person</span>, <span class="string">&#x27;Ocean&#x27;</span>, <span class="string">&#x27;Wang&#x27;</span>);</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这并不是 new 的完整实现，因为它没有创建原型（prototype）链。想举例说明 new 的实现有些困难，因为你不会经常用到这个，但是适当了解一下还是很有用的。</p>
</blockquote>
<h3 id="3-使用-prototype-原型链"><a href="#3-使用-prototype-原型链" class="headerlink" title="3. 使用 (prototype) 原型链"></a>3. 使用 (prototype) 原型链</h3><p>我们回过头来看这个定义类和初始化对象的方法,我们知道在 javascript 中, 定义 <code>function</code> 实际是生成了一个新的 <code>function</code> 对象, 所以每次 <code>new Person()</code> 时都会构造两个新的对象而这些对象的功能都是类似的, 有办法复用吗? 比如这样</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">personFullName</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">personFullNameReversed</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullName</span> = personFullName;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fullNameReversed</span> = personFullNameReversed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法的好处是，我们只需要创建一次方法函数，在构造函数中引用它们, 那是否还有更好的方法呢？答案是肯定的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">first, last</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">first</span> = first;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">last</span> = last;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullName</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span> + <span class="string">&#x27; &#x27;</span> + <span class="variable language_">this</span>.<span class="property">last</span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">fullNameReversed</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">last</span> + <span class="string">&#x27;, &#x27;</span> + <span class="variable language_">this</span>.<span class="property">first</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>Person.prototype 是一个可以被 Person 的所有实例共享的对象。它是一个名叫原型链（prototype chain）的查询链的一部分：当你试图访问 Person 某个实例（例如上个例子中的 s）一个没有定义的属性时，解释器会首先检查这个 Person.prototype 来判断是否存在这样一个属性。所以，任何分配给 Person.prototype 的东西对通过 this 对象构造的实例都是可用的。</p>
<p>这个特性功能十分强大，JavaScript 允许你在程序中的任何时候修改原型（prototype）中的一些东西，也就是说你可以在运行时(runtime)给已存在的对象添加额外的方法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">s = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&#x27;Simon&#x27;</span>, <span class="string">&#x27;Willison&#x27;</span>);</span><br><span class="line">s.<span class="title function_">firstNameCaps</span>(); <span class="comment">// TypeError on line 1: s.firstNameCaps is not a function</span></span><br><span class="line"></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">firstNameCaps</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">first</span>.<span class="title function_">toUpperCase</span>();</span><br><span class="line">&#125;;</span><br><span class="line">s.<span class="title function_">firstNameCaps</span>(); <span class="comment">// SIMON</span></span><br></pre></td></tr></table></figure>

<h4 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h4><p>以上我们简单聊了下 Javascript 创建对象的方法,和其中的原理, 由于 JS 是基于原型链的特性,JS 的继承机制也与其他面向对象的语言有很多不同,具体可以参考这个文档: <a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain">MDN - 继承与原型链</a></p>
<blockquote>
<p>Reference:</p>
<ul>
<li><em><a href="hhttps://developer.mozilla.org/zh-CN/docs/Web/JavaScript/A_re-introduction_to_JavaScript#%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1">MDN - A_re-introduction_to_JavaScript#自定义对象</a></em></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/05/19/javsscript-promise-vs-timeout/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/05/19/javsscript-promise-vs-timeout/" class="post-title-link" itemprop="url">Javascript 中 Promise 与 setTimeout 的执行顺序</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-05-19 23:08:07" itemprop="dateCreated datePublished" datetime="2021-05-19T23:08:07+08:00">2021-05-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>考虑以下这种情况, 哪条语句会先打印？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;timeout&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;promise&quot;</span>);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;main&quot;</span>);</span><br></pre></td></tr></table></figure>

<p>在考虑这个问题之前，我们有必要了解一下 javascript 的运行机制。  </p>
<p>首先我们要明白一个基本原理，Javascript，无论是基于浏览器还是基于 Nodejs 环境，都是基于事件循环（event loop) 而运行的:  </p>
<blockquote>
<p>Javascript 引擎在大多数情况下不做任何事情，直到有脚本、处理程序、事件来激活它, 这里的脚本、处理程序、事件都统称为任务，当任务到来时，如果 javascript 本身在执行其他任务，就会把这个新的任务放到 evet loop 中，直到当前任务执行完毕。  </p>
</blockquote>
<p>这样我们可以尝试初步理解开头那个场景会发生什么：</p>
<ol>
<li>Javascript 执行当前脚本</li>
<li>setTimeout 触发了一个新的事件，这个事件到来时，JS 引擎被当前脚本占据，<code>console.log(&quot;timeout&quot;);</code> 被放到 eventloop 中，脚本继续往下执行</li>
<li>Promise 抛出一个新的任务，<code>console.log(&quot;promise&quot;);</code> 也被放到 eventloop 中（这里的 eventloop 与 2 中的其实并不相同，我们后文在讲）</li>
<li>运行 <code>console.log(&quot;main&quot;);</code>, <code>&quot;main&quot;</code> 被打印出来</li>
<li>这时当前脚本执行完毕，JS 引擎闲置，则会执行 eventloop 中的任务 <code>console.log(&quot;timeout&quot;);</code> 与 <code>console.log(&quot;promise&quot;);</code></li>
</ol>
<p>通过上面的步骤，似乎是 <code>timeout</code> 会比 <code>promise</code> 先打印？但是这并不与实际 JS 中的运行结果一致，发生了什么呢？</p>
<p>这里就涉及到了我们 3 中提到的 eventloop 与 2 中不一致的问题，javascript 中对于 eventloop 或者说任务队列，其实分为两种，  宏任务 (macrotask) 微任务(microtask).</p>
<ul>
<li>宏任务<br> 对于常见的事件，例如：setTimeout, ajax 请求， 浏览器事件，都会被放到宏任务中</li>
<li>微任务<br> 微任务只能有程序创建，例如 promise, async/await(本质上也是 promise), 还有一种特殊的函数 <code>queueMicrotask(func)</code> 可以对 <code>func</code> 排队使其在 microtask 队列中运行  </li>
</ul>
<p><strong>微任务总是优先于宏任务执行</strong>。  </p>
<p>这样我们就可以继续之前的步骤  </p>
<ol>
<li>Javascript 执行当前脚本</li>
<li>setTimeout 触发了一个新的事件函数，这个事件到来时，JS 引擎被当前脚本占据，<code>console.log(&quot;timeout&quot;);</code> 被放到 宏任务队列 中，脚本继续往下执行</li>
<li>Promise 抛出一个新的任务，<code>console.log(&quot;promise&quot;);</code> 也被放到 微任务队列 中</li>
<li>运行 <code>console.log(&quot;main&quot;);</code>, <code>&quot;main&quot;</code> 被打印出来</li>
<li>这时当前脚本执行完毕，JS 引擎闲置，由于微任务队列非空，优先执行微任务 <code>console.log(&quot;promise&quot;);</code>, <code>&quot;promise&quot;</code> 被打印出来</li>
<li>这是微任务队列为空，JS 引擎去执行 宏任务队列中的任务 <code>console.log(&quot;timeout&quot;);</code>， <code>&quot;timeout&quot;</code> 被打印出来</li>
</ol>
<p>OK, 到目前，我们搞清楚了setTimeout  与 Promise 的执行顺序是由宏任务与微任务队列的优先级决定的，那么我们在其中考虑一个新的场景</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span> = <span class="string">&#x27;background:red&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span> = <span class="string">&#x27;background:black&#x27;</span>;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="title class_">Promise</span>.<span class="title function_">resolve</span>().<span class="title function_">then</span>(<span class="function">()=&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">document</span>.<span class="property">body</span>.<span class="property">style</span> = <span class="string">&#x27;background:white&#x27;</span>;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>请问目前页面的颜色改变了几次？</p>
<p>要回答这个问题，我们比如引入一个新的知识点<strong>页面渲染</strong>， 我们知道，当 JS 引擎被阻塞是，页面渲染是会被暂停的，只有 JS 引擎空闲时，页面才会完成渲染，这通常也是我们页面优化的一个方面：尽量避免 JS 引擎被长时间占据，这回导致页面是去反应。</p>
<blockquote>
<p>实际上页面渲染是GUI渲染线程来控制的，二这个线程与 JS 引擎线程互斥，导致了这种现象。<br>除此之外，浏览器里的线程一共有一下几种<br>    - 扩展GUI渲染线程<br>    - JS引擎线程<br>    - 事件触发线程<br>    - 定时触发器线程<br>    - 异步http请求线程  </p>
</blockquote>
<p>在我们目前的这个例子里, 这里出现了三个任务：</p>
<ul>
<li>主程序 - macrotask</li>
<li>timeout 任务 - macrotask</li>
<li>promise 任务 - microtask<br>通过之前第一个问题，我们知道这三个任务的执行顺序是： 主程序 -&gt; promise 任务 -&gt; timeout 任务  </li>
</ul>
<p>我们在这里需要判断 UI 渲染会发生在哪一个阶段，实际上，UI 渲染也是一个 macrotask, 所以 UI 渲染会发生在 promise 任务之后，接下来要判断的问题是 UI 渲染任务与 timeout 任务的顺序问题， 这里按照标准 预期的顺序应该是 <code>&#39;background:white&#39;</code> 开始 rendering ,然后 setTimeout , <code>&#39;background:black&#39;</code> 开始 rendering, 但是实际如果再浏览器中测试，可能看不到 <code>&#39;background:white&#39;</code> 的 rendering 过程。</p>
<blockquote>
<p>参考:  </p>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://zh.javascript.info/event-loop">事件循环：微任务和宏任务</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://zh.javascript.info/microtask-queue">微任务（Microtask）</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop">MDN - EventLoop</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://stackoverflow.com/questions/779379/why-is-settimeoutfn-0-sometimes-useful">stackoverflow-why-is-settimeoutfn-0-sometimes-useful</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://lqqjohnny.github.io/2018/07/24/%E4%B8%BA%E4%BB%80%E4%B9%88js%E4%BC%9A%E9%98%BB%E5%A1%9E%E9%A1%B5%E9%9D%A2%E6%B8%B2%E6%9F%93%EF%BC%9F/">为什么js会阻塞页面渲染？</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/117d26a33610">从浏览器多进程到JS单线程</a></em></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/04/15/babel-corejs/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/04/15/babel-corejs/" class="post-title-link" itemprop="url">babel 配置 polyfill 几种方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-04-15 20:27:06" itemprop="dateCreated datePublished" datetime="2021-04-15T20:27:06+08:00">2021-04-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>corejs 升级到 version 3 之后, babel 中针对 corejs polyfill 有几种不同的配置, 主要使用@babel/preset-env 的 useBuiltIns 这个参数</p>
<h2 id="1-useBuiltIns-entry-with-corejs-3"><a href="#1-useBuiltIns-entry-with-corejs-3" class="headerlink" title="1. useBuiltIns: entry with corejs: 3"></a>1. useBuiltIns: entry with corejs: 3</h2><p>这种方式,要求开发者讲一下代码显式添加到项目的入口处</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/stable&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;regenerator-runtime/runtime&quot;</span>;</span><br></pre></td></tr></table></figure>

<p>babel 会将这段代码替换为目标环境需要的特定 polyfill, 例如,在 targeting 到 chrome 72 时,它会被替换为</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.array.unscopables.flat&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.array.unscopables.flat-map&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.object.from-entries&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/web.immediate&quot;</span>;</span><br></pre></td></tr></table></figure>

<h2 id="2-useBuiltIns-usage-with-corejs-3"><a href="#2-useBuiltIns-usage-with-corejs-3" class="headerlink" title="2. useBuiltIns: usage with corejs: 3"></a>2. useBuiltIns: usage with corejs: 3</h2><p>这种方式,不需要开发者添加 <code>core-js</code> <code>regenerator-runtime</code> 到项目入口, babel 会自动的将目标文件需要的 polyfills 添加到项目中<br>例如,如果我们有如下代码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>在 ie11 中会被被自动替换成</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.array.includes&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.array.iterator&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.object.to-string&quot;</span>;</span><br><span class="line"><span class="keyword">import</span> <span class="string">&quot;core-js/modules/es.set&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> set = <span class="keyword">new</span> <span class="title class_">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]);</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="title function_">includes</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>

<p>它跟 <code>entry</code> 选项的主要区别在于</p>
<ol>
<li><code>usage</code> 不需要在项目开头显式地添加 <code>import &quot;core-js/stable&quot;;</code></li>
<li><code>usage</code> 会在文件的作用域内添加被使用到的 polyfill, 而 <code>entry</code> 会在项目入口处添加</li>
<li><code>entry</code> 会根据目标环境(例如 ie11) 来添加所有的 polyfill, 而 <code>usage</code> 会检查被使用到的 polyfill</li>
</ol>
<h2 id="3-babel-plugin-transform-runtime-plugin"><a href="#3-babel-plugin-transform-runtime-plugin" class="headerlink" title="3. @babel/plugin-transform-runtime plugin"></a>3. @babel/plugin-transform-runtime plugin</h2><p>这个 plugin 可以使用 babel 的 注入 helper 来减少 codesize,通过是用这个 plugin, 可以代替使用 @babel/preset-env 的 useBuiltIns 的功能, 即 <code>&quot;useBuiltIns&quot;: false,</code>,这个插件与使用 useBuiltIns 主要有两个差别</p>
<ol>
<li>使用 <code>useBuiltIns</code> 的 polyfill 会污染全局变量, 而 <code>plugin-transform-runtime</code> 不会, <a target="_blank" rel="noopener" href="https://babeljs.io/docs/en/babel-plugin-transform-runtime#technical-details">这里</a>可以找他关于相关的技术细节</li>
<li>使用 <code>plugin-transform-runtime</code> 可以显著降低输出的文件体积, 所以一般建议在开发 sdk 是使用这个配置</li>
</ol>
<blockquote>
<p>参考:</p>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://stackoverflow.com/q/52625979">Confused about useBuiltIns option of @babel/preset-env (using Browserslist Integration)</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://github.com/zloirock/core-js/blob/master/docs/2019-03-19-core-js-3-babel-and-a-look-into-the-future.md">core-js@3, babel and a look into the future</a></em></li>
<li><em><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844903849853976590">致我们学前端的小时光—corejs与env、runtime的不解之缘</a></em></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/03/19/http-cache-mechanism/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/19/http-cache-mechanism/" class="post-title-link" itemprop="url">HTTP 缓存机制详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-19 13:57:05" itemprop="dateCreated datePublished" datetime="2021-03-19T13:57:05+08:00">2021-03-19</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="1-缓存的级别"><a href="#1-缓存的级别" class="headerlink" title="1. 缓存的级别"></a>1. 缓存的级别</h3><p>从是否需要向浏览器请求资源来说，浏览器资源的缓存分成以下几个级别</p>
<h4 id="1-1-不缓存-不使用本地缓存"><a href="#1-1-不缓存-不使用本地缓存" class="headerlink" title="1.1 不缓存 - 不使用本地缓存"></a>1.1 不缓存 - 不使用本地缓存</h4><p>每次客户端的请求都需要服务器返回完整资源<br>不用缓存使用的请求头是  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Cache-Control:</span> <span class="literal">no</span><span class="string">-store</span></span><br></pre></td></tr></table></figure>

<h4 id="1-2-强缓存-直接使用本地缓存"><a href="#1-2-强缓存-直接使用本地缓存" class="headerlink" title="1.2 强缓存 - 直接使用本地缓存"></a>1.2 强缓存 - 直接使用本地缓存</h4><p>不会向服务器发送请求，直接从缓存中读取资源，在chrome控制台的network选项中可以看到该请求返回200的状态码;<br>强缓存的请求头是</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Cache-Control:</span> <span class="string">max-age=&lt;seconds&gt;</span></span><br></pre></td></tr></table></figure>

<p>这里的 max-age 参数表示本地缓存的过期时间,浏览器在尝试请求资源时,会查询当前资源是否已经存在本地缓存中,并且 max-age 没有到期,如果满足这个条件, 就会直接存本地缓存中读取文件.  </p>
<h4 id="1-3-协商缓存-向浏览器确认后使用本地缓存"><a href="#1-3-协商缓存-向浏览器确认后使用本地缓存" class="headerlink" title="1.3 协商缓存 - 向浏览器确认后使用本地缓存"></a>1.3 协商缓存 - 向浏览器确认后使用本地缓存</h4><p>向服务器发送请求，服务器会根据这个请求的request header的一些参数来判断是否命中协商缓存，如果命中，则返回304状态码并带上新的response header通知浏览器从缓存中读取资源；<br>协商缓存的请求头是:  </p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Cache-Control:</span> <span class="literal">no</span><span class="string">-cache,</span> <span class="string">max-age=&lt;seconds&gt;</span></span><br></pre></td></tr></table></figure>

<p>在这个过程中，浏览器向服务器发起请求来判断资源是否过期有两种不同的策略  </p>
<h5 id="1-3-1-基于时间的判断"><a href="#1-3-1-基于时间的判断" class="headerlink" title="1.3.1 基于时间的判断"></a>1.3.1 基于时间的判断</h5><p>服务器将资源传递给客户端时，会将资源最后更改的时间以“Last-Modified: GMT”的形式加在实体首部上一起返回给客户端。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Last-Modified:</span> <span class="string">Fri,</span> <span class="number">22</span> <span class="string">Jul</span> <span class="number">2020 01:47:00 </span><span class="string">GMT</span></span><br></pre></td></tr></table></figure>

<p>客户端会为资源标记上该信息，下次再次请求时，会把该信息附带在请求报文中一并带给服务器去做检查，</p>
<ul>
<li>若传递的时间值与服务器上该资源最终修改时间是一致的，则说明该资源没有被修改过，直接返回304状态码，内容为空，这样就节省了传输数据量 。</li>
<li>如果两个时间不一致，则服务器会发回该资源并返回200状态码，和第一次请求时类似。这样保证不向客户端重复发出资源，也保证当服务器有变化时，客户端能够得到最新的资源。一个304响应比一个静态资源通常小得多，这样就节省了网络带宽。  </li>
</ul>
<p>这里的客户端传递标记给服务器去判断最终修改时间的请求报文首部字段一共有两个：</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">If-Modified-Since:</span> <span class="string">Last-Modified-value</span> </span><br><span class="line"><span class="attr">If-Unmodified-Since:</span> <span class="string">Last-Modified-value</span> </span><br></pre></td></tr></table></figure>

<ul>
<li><code>If-Modified-Since</code> 是比较常见的缓存用法, 用于 GET/HEAD, 返回 304 或 200(资源过期的话)  </li>
<li><code>If-Unmodified-Since</code> 通常用于校验某个任务重服务器资源没有改变, 例如编辑某个wiki 页面,验证页面在编辑过程中发生了修改,就拒绝提交, 或者断点续传过程中发现服务器资源发生了修改就停止续传,通使用状态码 412 （Precondition Failed，前置条件失败）</li>
</ul>
<h5 id="1-3-2-基于-Etag-的判断"><a href="#1-3-2-基于-Etag-的判断" class="headerlink" title="1.3.2 基于 Etag 的判断"></a>1.3.2 基于 Etag 的判断</h5><p>这里的 Etag 是一个文件的标识符, 有服务器端生成, 不同的服务器使用的算法不一样, 通常用的可能是 Hash 算法, 当 Etag 校验与时间校验同时存在是, Etag 拥有 更高的优先级,时间检验会被忽略.<br>Etag  校验也要两个请求头,</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">If-Match:</span> <span class="string">&lt;etag_value&gt;</span> <span class="string">//</span> <span class="string">与</span> <span class="string">If-Modified-Since</span> <span class="string">类似</span></span><br><span class="line"><span class="attr">If-None-Match:</span> <span class="string">&lt;etag_value&gt;</span> <span class="string">//</span> <span class="string">与</span> <span class="string">If-Unmodified-Since</span> <span class="string">类似</span></span><br></pre></td></tr></table></figure>

<p>上述的 Catche-Control 机制都出现在 HTTP 1.1 版本中,在早期的 HTTP 1.0 中,还使用了 Expires 与 Pragma 两个参数来控制缓存, Expires 与  <code>max-age=&lt;seconds&gt;</code> 功能类似, 只是 Expires 用的是绝对时间(基于服务器时间),这会导致服务器时间与本地不一致时, 缓存控制紊乱, 而Prama 请求头与 <code>no-cache</code> 作用基本一样.  </p>
<p>在两种版本的请求头同时出现的情况下, 1.1 的指令拥有更高的优先级</p>
<h3 id="2-缓存的角色"><a href="#2-缓存的角色" class="headerlink" title="2. 缓存的角色"></a>2. 缓存的角色</h3><p>使用缓存的角色, 还有两种分类方法,</p>
<h4 id="2-1-private-私有-浏览器缓存"><a href="#2-1-private-私有-浏览器缓存" class="headerlink" title="2.1 private -(私有)浏览器缓存"></a>2.1 private -(私有)浏览器缓存</h4><p>私有缓存只能用于单独用户。你可能已经见过浏览器设置中的“缓存”选项。浏览器缓存拥有用户通过 HTTP 下载的所有文档。这些缓存为浏览过的文档提供向后/向前导航，保存网页，查看源码等功能，可以避免再次向服务器发起多余的请求。它同样可以提供缓存内容的离线浏览。</p>
<h4 id="2-2-public-共享-代理缓存"><a href="#2-2-public-共享-代理缓存" class="headerlink" title="2.2 public - (共享)代理缓存"></a>2.2 public - (共享)代理缓存</h4><p>共享缓存可以被多个用户使用。例如，ISP 或你所在的公司可能会架设一个 web 代理来作为本地网络基础的一部分提供给用户。这样热门的资源就会被重复使用，减少网络拥堵与延迟。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">Cache-Control:</span> <span class="string">public,</span> <span class="string">max-age=&lt;seconds&gt;</span></span><br><span class="line"><span class="attr">Cache-Control:</span> <span class="string">private,</span> <span class="string">max-age=&lt;seconds&gt;</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考:  </p>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Caching">MDN - HTTP cache</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/1a1536ab01f1">强制缓存和协商缓存有什么区别</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/60357719">可能是最被误用的 HTTP 响应头之一 Cache-Control: must-revalidate</a></em>  </li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2021/03/17/javascript-var-let-difference-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2021/03/17/javascript-var-let-difference-md/" class="post-title-link" itemprop="url">Javascript 中的变量声明 - let, const, var</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2021-03-17 23:08:07" itemprop="dateCreated datePublished" datetime="2021-03-17T23:08:07+08:00">2021-03-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>Javascript 支持的变量声明方式其实有四种 <code>var</code> <code>let</code> <code>const</code> <code>隐式创建</code></p>
<h3 id="一-隐式创建变量"><a href="#一-隐式创建变量" class="headerlink" title="一 . 隐式创建变量"></a>一 . 隐式创建变量</h3><p>当赋值给未声明的变量, 则执行赋值后, 该变量会被隐式地创建为全局变量（它将成为全局对象的属性）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">x</span>(<span class="params"></span>) &#123;</span><br><span class="line">  y = <span class="number">1</span>;   <span class="comment">// 在严格模式（strict mode）下会抛出 ReferenceError 异常</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">x</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(y); <span class="comment">// 打印 &quot;1&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="二-使用-var-创建变量"><a href="#二-使用-var-创建变量" class="headerlink" title="二. 使用 var 创建变量"></a>二. 使用 var 创建变量</h3><p>var 是 ES6 发布之前仅存的一种变量声明方式，用 var 声明变量有一下几个特征</p>
<h4 id="1-作用域"><a href="#1-作用域" class="headerlink" title="1. 作用域"></a>1. 作用域</h4><p>var 的作用域只有两种 函数级别作用域 和 全局作用域 (let const 可以声明块作用域，这个我们在后面会谈到)</p>
 <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全局作用域</span></span><br><span class="line"><span class="keyword">var</span> a  = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块作用域不会生效</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="literal">true</span>; <span class="comment">// 使用 &quot;var&quot; 而不是 &quot;let&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">alert</span>(b); <span class="comment">// true，变量在 if 结束后仍存在</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数作用域</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> c = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(c); <span class="comment">// 能正常工作</span></span><br><span class="line">  <span class="title function_">alert</span>(a); <span class="comment">// 正常工作</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br><span class="line"><span class="title function_">alert</span>(c); <span class="comment">// Error: phrase is not defined</span></span><br></pre></td></tr></table></figure>

<h4 id="2-重复声明"><a href="#2-重复声明" class="headerlink" title="2. 重复声明"></a>2. 重复声明</h4><p>var 可以被声明多次, 新的声明会被忽略</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;Pete&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> user = <span class="string">&quot;John&quot;</span>; <span class="comment">// 这个 &quot;var&quot; 无效（因为变量已经声明过了), 这里就是简单的赋值操作</span></span><br><span class="line"><span class="comment">// ……不会触发错误</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">alert</span>(user); <span class="comment">// John</span></span><br></pre></td></tr></table></figure>

<h4 id="3-声明提升"><a href="#3-声明提升" class="headerlink" title="3. 声明提升"></a>3. 声明提升</h4><p>“var” 声明的变量，可以在其声明语句前被使用<br>当函数开始的时候，就会处理 var 声明（脚本启动对应全局变量）。<br>换言之，var 声明的变量会在函数开头被定义，与它在代码中定义的位置无关（这里不考虑定义在嵌套函数中的情况）。</p>
<p>例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="title function_">alert</span>(a);</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>与下面这种写法本质是一样的</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a;</span><br><span class="line">  a = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line">  <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<p>甚至于这种都是一样的 (由于 var 只有函数级的作用域，所以代码块是会被忽略的）)</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">sayHi</span>(<span class="params"></span>) &#123;</span><br><span class="line">  a = <span class="string">&quot;Hello&quot;</span>; </span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">alert</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">sayHi</span>();</span><br></pre></td></tr></table></figure>

<blockquote>
<p>其实这种声明提升作用在定义 function 的时候也会出现,例如</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>() <span class="comment">// print foo</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)&#125; </span><br></pre></td></tr></table></figure>

<p>是可以正常运行的<br>但是以下这种不行</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="title function_">foo</span>() <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="keyword">function</span>(<span class="params"></span>) &#123;<span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;foo&#x27;</span>)&#125; </span><br></pre></td></tr></table></figure>
</blockquote>
<h4 id="4-全局声明"><a href="#4-全局声明" class="headerlink" title="4. 全局声明"></a>4. 全局声明</h4><p>var 在全局声明是会绑定成全局属性</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">this</span>.<span class="property">a</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<h3 id="IIFE"><a href="#IIFE" class="headerlink" title="IIFE"></a>IIFE</h3><p>在 ES6 发布之前，Javascript 只有 var 这一种声明方式，并且这种声明方式没有块级作用域，开发者发明了一种模仿块级作用域的方法： “立即调用函数表达式”（immediately-invoked function expressions，IIFE）。<br>如今，在有 let, const 声明变量的方式， IIFE 已经不再被使用了，但是我们经常还是可以再一些老的 code 中看到它</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line"> <span class="keyword">var</span> message = <span class="string">&quot;Hello&quot;</span>;</span><br><span class="line"> <span class="title function_">alert</span>(message); <span class="comment">// Hello</span></span><br><span class="line">&#125;)();</span><br><span class="line"><span class="title function_">alert</span>(message) <span class="comment">// Uncaught ReferenceError: message is not defined</span></span><br></pre></td></tr></table></figure>

</blockquote>
<hr>
<h3 id="三-使用-let-创建变量"><a href="#三-使用-let-创建变量" class="headerlink" title="三. 使用 let 创建变量"></a>三. 使用 let 创建变量</h3><p>let 是 ES6 中被引进的一种变量定义方式，它与 var 声明变量主要有这几个区别</p>
<ul>
<li>增加了块级作用域</li>
<li>消除变量提升作用（暂存死区TDZ(Temporal Dead Zone)）</li>
<li>在一个作用域中不可重复声明</li>
</ul>
<hr>
<h4 id="1-块级作用域"><a href="#1-块级作用域" class="headerlink" title="1. 块级作用域"></a>1. 块级作用域</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>() <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>

<h4 id="2-暂存死区"><a href="#2-暂存死区" class="headerlink" title="2. 暂存死区"></a>2. 暂存死区</h4><p>不同于 var, 所有的变量声明会被提升到作用域的开头位置，在声明前引用是合法的，let 的声明只有在执行到声明那一刻才会正式生效。  </p>
<p>在程序的控制流程在新的作用域进行实例化时，在此作用域中用let、const声明的变量会在该作用域中先创建，但这个时候还没有进行词法绑定，没有进行对声明语句的赋值运算，所以是不能访问的，访问会抛出错误。所以在这运行流程一进入作用域创建变量，到变量开始可被访问的一段时间，就称为TDZ。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(a) <span class="comment">// undefined</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// undefined, 这个时候是隐式声明， 在严格模式（strict mode）下会抛出 ReferenceError 异常</span></span><br><span class="line">b = <span class="number">0</span>; </span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(b) <span class="comment">// Uncaught ReferenceError：a is not defined</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<p>这个暂存死区，放到词法作用域/静态作用域中会产生一个有趣的现象</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>)&#123;</span><br><span class="line"><span class="keyword">let</span> foo = <span class="number">33</span>;</span><br><span class="line"><span class="keyword">if</span> (foo) &#123;</span><br><span class="line">    <span class="keyword">let</span> foo = (foo + <span class="number">55</span>); <span class="comment">// Uncaught ReferenceError</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">test</span>();</span><br></pre></td></tr></table></figure>

<p>这是因为在进入 if 代码块之后，程序识别到一个新的 <code>foo</code> 已经被创建了，而且在被正式赋值之前，这个 <code>foo</code> 是不可被引用的， <code>(foo + 55)</code> 中 <code>foo</code> 并不能引用到外层词法作用域中的 <code>let foo = 33;</code></p>
<h4 id="3-非全局属性"><a href="#3-非全局属性" class="headerlink" title="3. 非全局属性"></a>3. 非全局属性</h4><p>let不会在全局声明时（在最顶部的范围）创建 window/this 对象的属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">a</span>); <span class="comment">// 1</span></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>; </span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">window</span>.<span class="property">b</span>); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>

<h3 id="四-使用-const-创建变量"><a href="#四-使用-const-创建变量" class="headerlink" title="四. 使用 const 创建变量"></a>四. 使用 const 创建变量</h3><p><code>const</code> 创建变量与 <code>let</code> 基本是一致的，只是 <code>const</code> 不能被重新赋值, 而且必须在创建的同时给它初始值.  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="number">1</span>;</span><br><span class="line">a = <span class="number">2</span>; <span class="comment">// Uncaught TypeError: Assignment to constant variable.</span></span><br><span class="line">cosnt b; <span class="comment">// Uncaught SyntaxError: Missing initializer in const declaration</span></span><br></pre></td></tr></table></figure>

<p>这里要注意的是，不能被赋值的是 <code>const</code> 声明的变量这个引用本身，但是对引用的引用是不受影响的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;</span><br><span class="line">    <span class="attr">bar</span>: <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">foo.<span class="property">bar</span> = <span class="number">2</span> <span class="comment">// ok</span></span><br><span class="line">foo = <span class="number">2</span>; <span class="comment">// Uncaught TypeError</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = [<span class="number">1</span>]</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">2</span> <span class="comment">// ok</span></span><br><span class="line">arr = [<span class="number">2</span>] <span class="comment">// Uncaught TypeError</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>参考:  </p>
<ul>
<li><em><a target="_blank" rel="noopener" href="https://zh.javascript.info/var">旧时的 var</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/let">MDN Web Doc - let</a></em>  </li>
<li><em><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/var">MDN Web Doc - var</a></em></li>
</ul>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2019/05/17/How-to-create-a-new-post/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/17/How-to-create-a-new-post/" class="post-title-link" itemprop="url">怎么在 Hexo 中创建一篇新的文章</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-17 17:36:10" itemprop="dateCreated datePublished" datetime="2019-05-17T17:36:10+08:00">2019-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h3 id="安装-hexo-命令"><a href="#安装-hexo-命令" class="headerlink" title="安装 hexo 命令"></a>安装 hexo 命令</h3><p>创建一篇新的文章需要使用 <code>hexo</code> 命令， <code>hexo</code> 命令有两种安装方式</p>
<h4 id="通过-npm-全局安装"><a href="#通过-npm-全局安装" class="headerlink" title="通过 npm 全局安装"></a>通过 <code>npm</code> 全局安装</h4><ol>
<li><code>npm instal -g hexo</code></li>
<li><code>hexo new [layout] &lt;title&gt;</code></li>
</ol>
<p>Arguments:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">layout  Post layout. Use post, page, draft or whatever you want.</span><br><span class="line">title   Post title. Wrap it with quotations to escape.</span><br></pre></td></tr></table></figure>

<h4 id="将-hexo-安装到当前目录下"><a href="#将-hexo-安装到当前目录下" class="headerlink" title="将 hexo 安装到当前目录下"></a>将 <code>hexo</code> 安装到当前目录下</h4><p>通常我们在项目中执行 <code>npm install</code> 后 <code>hexo</code> 就已经安装到了<code>./node_modules/</code> 中，我们可以通过路径 <code>./node_modules/hexo/bin/hexo</code> 来使用, 为了方便使用，我们可以将命令写到 <code>package.json</code> 中</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;scripts&quot;</span>: &#123;</span><br><span class="line">  <span class="string">&quot;hexo&quot;</span>: <span class="string">&quot;./node_modules/hexo/bin/hexo&quot;</span>,</span><br><span class="line">  <span class="string">&quot;create&quot;</span> : <span class="string">&quot;./node_modules/hexo/bin/hexo new&quot;</span></span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<h3 id="创建新的文章"><a href="#创建新的文章" class="headerlink" title="创建新的文章"></a>创建新的文章</h3><p>通常如果要发布一个新的文章，可以通过如下步骤</p>
<ol>
<li>使用 <code>hexo new draft &lt;title&gt;</code> 来生成一个 draft</li>
<li>编辑 draft, 通过 <code>hexo server --draft</code> 来预览</li>
<li>编辑完成之后使用 <code>hexo publish post &lt;title&gt;</code> 来将 draft 发布到 post 下</li>
<li>使用 <code>hexo clean &amp;&amp; hexo deploy</code> 来发布最新的页面 (通常这个新的页面可能需要等几分钟才能生效)</li>
</ol>
<p>详细的说明可以可以在<a target="_blank" rel="noopener" href="https://hexo.io/docs/writing">这里</a>看到具体的官方文档</p>
<h3 id="关于-markdown-语法"><a href="#关于-markdown-语法" class="headerlink" title="关于 markdown 语法"></a>关于 markdown 语法</h3><ul>
<li>语法速查 - <a target="_blank" rel="noopener" href="https://www.markdown.xyz/basic-syntax">Markdown 指南中文版</a></li>
</ul>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="https://anoce0.github.io/2019/05/17/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Ocean Wang">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Ocean's Blog">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | Ocean's Blog">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/17/hello-world/" class="post-title-link" itemprop="url">Hello World</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">Posted on</span>

      <time title="Created: 2019-05-17 17:36:10" itemprop="dateCreated datePublished" datetime="2019-05-17T17:36:10+08:00">2019-05-17</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">Edited on</span>
      <time title="Modified: 2024-05-06 21:05:06" itemprop="dateModified" datetime="2024-05-06T21:05:06+08:00">2024-05-06</time>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/deployment.html">Deployment</a></p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>





</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2024</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Ocean Wang</span>
  </div>
  <div class="powered-by">Powered by <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a>
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="Back to top">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/sidebar.js"></script><script src="/js/next-boot.js"></script>

  






  





</body>
</html>
